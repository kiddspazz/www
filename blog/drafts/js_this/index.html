<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>this, apply, call, bind</title>
    <meta name='viewport' content="width=device-width, initial-scale=1.0"/>
    <link id="favicon" href="/res/images/favicons/travFavicon.png" type="image/png" rel="icon">
    <link href="/res/css/stylesheet.css" type="text/css" rel="stylesheet"/>
    <script src="/res/js/loadHeader.js"></script>
    <script src="/res/js/loadFooter.js"></script>
  </head>

  <body>
    <div class="container">
      <main class="content">
      <div class="main">
        <h1>Javascript <code>this</code>, <code>apply</code>, <code>call</code>, and <code>bind</code></h1>
        <p>Notes on JavaScript's <code>this</code> and associated methods.</p>
        <p>From MDN: <blockquote><code>this</code>: A property of an execution context (global, function or eval) that, in nonâ€“strict mode, is always a reference to an object and in strict mode can be any value.</blockquote></p>
        <p>Yeah, what the hell does that mean. Let's walk through it, starting with the stuff I already understand.</p>
        <p>An object! I know what that is. So <code>this</code> is always a reference to an object. Which object? I guess we'll get to that.</p>
        <p>A property: basically a variable associated with the thing.</p>
        <p>Strict vs non-strict modes. Well, I haven't really done anything in strict mode, but from what I understand it makes you be more explicit about your code. That sort of makes sense in context here: you have to declare exactly what <code>this</code> is when you're in strict mode, whereas non-strict mode JavaScript will try to figure out what you mean.</p>
        <p>And then, execution context. ?? At least this definition gives us a nice hint with "(global, function, or eval)". So I'm gonna go with: a context for executing. Sounds reasonable. Executing...a function? I don't know.</p>
        <p>More from MDN: <blockquote>In the global execution context (outside of any function), this refers to the global object whether in strict mode or not.</blockquote></p>
        <p>Alright. So when you're in the global scope, <code>this</code> is just the global object (<code>window</code> in the DOM).</p>
        <code>this.b = 37;
          console.log(window.b); // 37
          console.log(b); // 37</code>
        <p>And one more quote from MDN: <blockquote>Inside a function, the value of this depends on how the function is called.</blockquote></p>
        <p>From here on, I'm going to just rephrase what the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this">MDN article</a> says. I'm also going to leave out their treatment of strict mode.</p>
        <p><h3>A simple function call:</h3> <code>this</code> is just the global object (<code>window</code> in the DOM).</p>
        <p>However, JS has three ways to change this behavior: <code>call</code>, <code>apply</code>, and <code>bind</code>. <code>bind</code> was added in ES5 (before my time as a developer). These three each affect <code>this</code> in different ways:</p>
        <p><h4><code>call</code> and <code>apply</code>:</h4>From a quick search of the internet, the difference between these two seem like a legacy issue. They both allow you to assign <code>this</code> when calling a function, though with slightly different syntax.</p>
        <p><code><b>a</b>pply</code> takes up to two parameters: <code>.apply(this, [...])</code>, which is to say the first is the <code>this</code> you want to reference within the function call, and an <b>a</b>rray with arguments you pass to the function itself. (Yeah, you did notice the bolded "a"s: that's the little pnemonic device the internet suggested to remember the difference between <code>apply</code> and <code>call</code>.</p>
        <p><code><b>c</b>all</code> takes zero or more parameters, seperated by the standard <b>c</b>ommas: <code>.call(this, param1, param2...)</code>. The 2nd and following parameters are the arguments that get passed to the function itself. (<code>call</code> &#x2192; comma, <code>apply</code> &#x2192; array).</p>
        <p><code>bind</code> is a different beast. <code>bind</code> creates a new function from (1) a given function and (2) a given object that <code>bind</code>s itself to the new function as the new function's <code>this</code>.</p>
        <p><h3>Arrow functions:</h3>In ES6 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions">Arrow functions</a> were introduced. They are worthy of <a href="https://hacks.mozilla.org/2015/06/es6-in-depth-arrow-functions/">several</a> <a href="https://stackabuse.com/arrow-functions-in-javascript/">different</a> <a href="https://developer.blog/es6-arrow-functions/">articles</a> in themselves. For the purposes of these notes, the important thing to remember is that <code>this</code> retains the value it had within whatever called the arrow function. This functionality can be useful for using helper functions within other functions, for class constructions, and other fun things too.</p>
        <p><h3>Other cases</h3>There are essentially three other cases where <code>this</code> has different functionality: <ol><li>objects: this is the object</li><li>constructors: this is the new object beign created</li><li>and event handlers: this is the element that fired the event</li></ol>The <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this">MDN Docs</a> go into much more detail about those three cases.</p>
        <hr>
        <p>A little code:</p>
        <code>const svgNS = "http://www.w3.org/2000/svg"
          const svg = document.getElementById('svg');

          class Shape {
            constructor(fill = 'transparent', stroke = 'black') {
              this.fill = fill;
              this.stroke = stroke;
            }
          }

          class Rect extends Shape {
            constructor(w, h, fill, stroke) {
              super(fill, stroke);
              this.w = w;
              this.h = h;
            }

            addto(parent, x, y) {
              let elem = document.createElementNS(svgNS, 'rect');
                elem.setAttributeNS(null, 'width', this.w);
                elem.setAttributeNS(null, 'height', this.h);
                elem.setAttributeNS(null, 'x', x);
                elem.setAttributeNS(null, 'y', y);
                elem.setAttributeNS(null, 'fill', this.fill);
                elem.setAttributeNS(null, 'stroke', this.stroke);
                parent.appendChild(elem);
            }
          }
      </div>
      </main>
    </div>
  </body>
</html>

